ByThePong — Resumo de Programação Orientada a Objetos (POO)

1) Visão Geral
- O projeto aplica POO para modelar os elementos do jogo Pong como objetos com estado e comportamento bem definidos.
- As principais entidades são: Game, Menu, Player, Ball, Paddle, ScoreManager e ResponsiveManager.
- O encapsulamento é aplicado com atributos privados (prefixo __) e acesso controlado via propriedades (@property), setters e métodos públicos.

2) Classes e Responsabilidades
- Player (player.py): gerencia nome e pontuação do jogador (add_point, reset_score). Encapsula __name, __score; validação no setter de name.
- Ball (ball.py): física e movimento da bola (move, bounce_x, bounce_y, bounce_paddle, reset, get_rect). Encapsula posição, velocidade e direção.
- Paddle (paddle.py): movimento das raquetes com limites de tela (move_up, move_down, set_position, get_rect, center_y). Encapsula posição, dimensões e velocidade.
- ScoreManager (score_manager.py): persistência e ranking (add_score, get_ranking, get_top_score, get_player_best_score, clear_ranking, get_ranking_display). Encapsula caminho do arquivo e lista de ranking, salva em JSON.
- ResponsiveManager (responsive_utils.py): adapta dimensões/tamanhos à resolução (scale_width, scale_height, scale_font_size, margins, paddle_props, ball_props). Encapsula fatores de escala.
- Game (game.py): orquestra o loop do jogo e integra os objetos (start_game, stop_game, update, handle_events, quit). Lida com entradas, IA do bot, colisões, placar, fim de jogo e HUD, além da dificuldade e responsividade.
- Menu (menu.py): fluxo de telas (main, name_input, difficulty, ranking), coleta nome/dificuldade, exibe ranking e dispara o início do jogo via callback.

3) Encapsulamento (como foi aplicado)
- Atributos internos são privados: __x, __y, __radius, __speed (Ball); __x, __y, __width, __height, __speed (Paddle); __name, __score (Player); __ranking_file, __ranking, __max_ranking_size (ScoreManager); atributos de estado do Game/Menu também são privados.
- Acesso seguro por propriedades e métodos:
  • Ex.: Ball.x / Ball.y usam @property; Game expõe width, height, player, score_manager.
  • Player.name possui setter com validação (não aceita string vazia).
- Regras de negócio preservadas dentro da classe:
  • Ball.bounce_paddle calcula ângulo/velocidade e garante velocidade mínima.
  • Paddle.move_up/move_down respeitam limites da tela.
  • ScoreManager só expõe cópia do ranking (get_ranking) e centraliza a persistência.

4) Abstração e Interfaces Públicas
- Cada classe define uma interface clara de uso:
  • Ball: move, bounce_x/y, bounce_paddle, reset, get_rect.
  • Paddle: move_up/down, set_position, get_rect, center_y.
  • Player: add_point, reset_score, name (getter/setter), score (getter).
  • ScoreManager: add_score, get_ranking, get_top_score, get_player_best_score, clear_ranking, get_ranking_display.
  • ResponsiveManager: scale_width/height/font, props e margins.
  • Game: start_game, update, handle_events, quit, set_player_name.
  • Menu: set_start_game_callback, update, handle_events, quit.

5) Relações entre Objetos (colaboração)
- main.py cria Menu, registra um callback (start_game_with_name) e delega o início do jogo.
- Game cria e coordena Player, Ball, Paddle(s), ScoreManager e ResponsiveManager.
- Menu usa ScoreManager para exibir ranking e chama o callback com (player_name, difficulty) para iniciar Game.
- Durante o jogo: Game lê input, move paddles/bola, verifica colisões, atualiza placar e, ao término, registra a pontuação via ScoreManager.

6) Configurações Principais e Responsividade
- Dificuldade (Game.__get_difficulty_settings): ajusta ai_difficulty, ball_speed e ai_speed por nível (fácil/normal/difícil/expert).
- Responsividade (ResponsiveManager): calcula fator de escala da tela e fornece dimensões proporcionais para paddles/bola, margens e fontes. Game/Menu usam esses valores para desenhar e posicionar elementos corretamente em diferentes resoluções (inclusive tela cheia).

7) Tratamento de Erros e Fluxo de Execução
- main.py encapsula execução com try/except para falhas inesperadas e KeyboardInterrupt (encerra pygame e sys.exit com segurança).
- ScoreManager lida com JSON inválido/arquivo ausente; operações de escrita são protegidas com try/except simples.

8) Extensibilidade (como o design facilita evoluções)
- Novas dificuldades: basta adicionar presets em Game.__get_difficulty_settings.
- Novos modos de jogo: criar classe de regra/IA e plugar em Game mantendo a interface de atualização.
- UI/Menu: novas telas/itens aproveitam ResponsiveManager para manter proporção visual.
- Persistência: ScoreManager isola leitura/escrita; mudar o backend (ex.: DB) não afeta Game/Menu.

9) Padrões e Boas Práticas Utilizados
- Encapsulamento forte: dados privados e invariantes garantidos dentro das classes.
- Separação de Responsabilidades: cada classe tem uma função única e coesa.
- Callback: Menu dispara o início do jogo por função registrada (baixo acoplamento entre Menu e Game).
- Property Pattern: getters/setters Python com @property para expor estado sem vazar implementação.
- Responsividade centralizada: ResponsiveManager concentra a lógica comum de escala.

10) Pontos-chave para apresentar (roteiro rápido)
- Modelo de Objetos: explique rapidamente cada classe e sua responsabilidade.
- Encapsulamento: destaque o uso de __atributos e @property, com o caso do Player.name validando entrada.
- Regras dentro dos objetos: Ball.bounce_paddle calcula ângulo/velocidade; Paddle respeita limites; ScoreManager persiste ranking com ordenação Top 10.
- Orquestração no Game: integra tudo (input → atualização de estado → colisões → pontuação → renderização); IA simples para o bot baseada na posição da bola.
- Responsividade: como a mesma base visual se adapta a diferentes resoluções (fonts, margens, tamanhos de objetos).
- Dificuldade: presets mudam velocidade/IA sem alterar a mecânica central (abstração e dados dirigindo comportamento).

11) Exemplo de narrativa (30–60s por tópico)
- “Modelamos as entidades do Pong como classes: Ball e Paddle encapsulam física e movimento; Player encapsula nome e pontuação; ScoreManager centraliza persistência; Game coordena o loop e as interações; Menu cuida da navegação e entrada.”
- “Aplicamos encapsulamento com atributos privados e propriedades. Por exemplo, Player.name valida entrada; Ball controla internamente velocidade/direção e calcula ângulos de rebote.”
- “A lógica de jogo fica dentro de Game, que consome as interfaces públicas dos objetos. Isso facilita evoluções como novas dificuldades, modos ou ajustes visuais, graças ao ResponsiveManager.”
- “A comunicação entre Menu e Game é por callback, reduzindo acoplamento. O ranking é salvo em JSON por ScoreManager, isolando a persistência.”

12) Arquivos relevantes (onde ver no código)
- player.py — classe Player (encapsulamento e validação de name)
- ball.py — classe Ball (movimento, rebotes e reset)
- paddle.py — classe Paddle (movimento limitado à tela)
- score_manager.py — ScoreManager (ranking e persistência JSON)
- responsive_utils.py — ResponsiveManager (escala e proporções)
- game.py — Game (loop, IA, colisões, HUD, dificuldade)
- menu.py — Menu (telas, input e callback para iniciar o jogo)
- main.py — ponto de entrada (integra Menu ↔ Game)

FIM
